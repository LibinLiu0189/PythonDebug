### 0.0 FP-growth相关概念
单个元素项的条件模式基也就是元素项的关键字；</br>
条件模式基:头部链表中的某一点的前缀路径组合就是条件模式基，条件模式基的值取决于末尾节点的值；</br>
条件FP树:以条件模式基为数据集构造的FP树叫做条件FP树；</br>

### 2.0 FP-growth步骤
##### 首先, 构建FP树；
步骤一：
1. 遍历所有的数据集合，计算所有项的支持度;
2. 丢弃非频繁的项;
3. 基于支持度降序排序所有(元)项(不是项集)，生成到统计;
4. 将所有数据集合中的每个集合按照得到的顺序(3)重新排序;
5. 排序完成后，丢弃每个集合末尾非频繁的项

步骤二：
6. 读取每个集合插入到FP树，同时用一个头部链表数据结构维护不同集合的相同项，FP树头结点为null

![FP-Tree.png](https://i.imgur.com/etpEgbp.png)
##### 其次,从FP树中挖掘频繁项集；
7. 对头部链表进行降序排列
8. 对头部链表节点从小到大遍历，得到条件模式基A1，同时获得一个频繁项集。
9. A1条件模式基继续构造条件FP树(从(5)得到的集合中的数据构造)， 得到频繁项集，和之前的频繁项组合起来，这是一个递归遍历头部链表生成FP树的过程，递归截止条件是生成的FP树的头部链表为空。

### 3.0 优劣
优点：
1. 因为 FP-growth 算法只需要对数据集遍历两次，所以速度更快。
2. FP树将集合按照支持度降序排序，不同路径如果有相同前缀路径共用存储空间，使得数据得到了压缩。
3. 不需要生成候选集。
4. 比Apriori更快。

缺点：
1. FP-Tree第二次遍历会存储很多中间过程的值，会占用很多内存。
2. 构建FP-Tree是比较昂贵的。

注：
1. 第一次遍历，得到所有频繁一项集的的计数。然后删除支持度低于阈值的项，将1项频繁集放入头部链表，并按照支持度降序排列。</br>
2. 第二次遍历，将读到的原始数据剔除非频繁1项集，并按照支持度降序排列。

适用数据类型：标称型数据(离散型数据)。

参考：

1. [刘建平：FP Tree算法原理总结](https://www.cnblogs.com/pinard/p/6307064.html)